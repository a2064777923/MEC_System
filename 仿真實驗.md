# 仿真實驗:

已實現內容總結:

1. 設計了MEC系統的模型，包括它的各種設定參數的定義和計算以及其運作模式

2. 實現了隨機生成MEC系統模型的方法，MEC系统拓扑的生成：使用MECSystemGenerator类生成MEC系统的拓扑结构，包括WD和MEC的数量、计算能力范围、传输功率等参数。

3. 實現了隨機生成應用和任務模型的方法，使用TaskDAGGenerator类生成任务的有向无环图（DAG），其中节点表示任务，边表示任务之间的依赖关系。考虑了DAG图的大小、最大出度、形状参数等自定義參數。

4. 信息计算器的设计：使用Calculator类实现了一些信息的计算功能，包括本地计算时延、MEC计算时延、计算通信比等。

5. 實現了測試環境接口

6. 本地执行算法：使用LocalExecute类实现了一个简单的比较基线算法，即将所有任务都在本地执行。该算法按照任务的最大容忍时延排序，并依次在空闲的WD上执行任务。

7. 效率贪婪算法：使用EfficiencyGreedyExecute类实现了一个效率贪婪算法。该算法考虑了任务的计算通信比，并在空闲的WD或MEC上选择最适合执行的任务。

## 1 MEC系統

### 1.1 系統建模:

**實驗情景包括多個MEC服務器和WD(目前只實現一個WD的情況)，實驗參數設置如下表(參數設置的依據為搜索得來的一些常規數值的均值、以及文献[1])**

| 參數                      | 說明                   | 值範圍        |
| ----------------------- | -------------------- | ---------- |
| CHANNEL_BANDWIDTHS      | 信道帶寬(MHz)            | 100        |
| CHANNEL_GAIN            | 信道增益，計算較複雜，先設為1      | 1          |
| BACKGROUND_NOISE        | 背景噪聲功率(dBm)          | -100       |
| WD_CALCULATION_SCOPE    | 移動設備CPU計算能力範圍(GHz)   | [1, 3]     |
| MEC_CALCULATION_SCOPE   | MEC服務器CPU計算能力範圍(GHz) | [2, 4]     |
| WD_TRANSMISSION         | 傳輸功率(mW)             | 100        |
| MEC_TRANSMISSION        | MEC傳輸功率(mW)          | 1000       |
| UPLINK_SIGNAL_FREQUENCY | 上行信號頻率(MHz)          | [825, 954] |
| WD_MEC_DISTANCE_SCOPE   | WD和MEC的距離範圍(m)       | [10, 5000] |

**每個WD和MEC間都有信道連接，標簽帶上兩端間的距離以及信道的最大傳輸效率信息:**

1. 最大傳輸效率(香農公式):

$$
R = B*log2(1+Hi*Pi/N0)
$$

2. Hi，系數，為信道增益*收發比值(路徑損耗)

3. **路徑損耗計算**：

路徑損耗 Lpath(db​) 可以根據自由空間路徑損耗模型計算：

$$
Lpath​=20*log10​(d)+20*log10​(f)+32.4
$$

其中，d 為信道長度(m)，f 為信號的頻率(Mhz)，中国移动：885-909（上行）、930-954Mhz（下行）；中国联通：909-915（上行）、954-960Mhz（下行）；中国电信：825-835（上行）、870-880Mhz（下行）。

- dBm轉mW:

$$
mW = 10.pow(dBm / 10)
$$

4. **接收功率計算**：

假設發射功率為 Ptx​，則接收功率 Prx​ 可以表示為：

$$
Prx​=Ptx​−Lpath​
$$

5. **收發比值計算**：

$$
G=Prx/​Ptx
$$

### 1.2 MEC拓樸生成:

  `MECSystemGenerator`類負責生成MEC系統的拓撲結構。該類通過隨機生成不同參數的節點和邊來模擬真實的MEC系統環境。使用時，根據需要的WD和MEC數量調用。

#### 1.2.1 每個WD節點的參數:

* type: 設備的類型

* calculation: 設備的計算能力

* transmission: 設備的傳輸功率

* signal_frequency: 設備的傳輸信號頻率

#### 1.2.2 每個MEC節點的參數:

- type: 設備的類型

- calculation: 設備的計算能力

- transmission: 設備的傳輸功率

#### 1.2.3 每台WD和每台MEC間信道連接的參數:

* distance: 節點間距離，單位為m

* maxTransmissionSpeed: 用香農公式計算得出的信道最大傳輸速度，單位為MB/s

#### 1.2.4 `generateMEC(WDNumber,MECNumber)`方法即可生成MEC系統。

#### 1.2.5 `MAX_TRANSMISSION_SPEEN`  方法是用來計算路徑的最大傳輸速率的，結果的單位為MB/s

#### 1.2.6 `draw_graph`用來繪制圖像

5*3:

<img src="file:///F:/Homework/畢业設計/MEC/Image/mec5x3.jpg" title="" alt="mec5x3.jpg" width="404">

15*5:

<img src="file:///F:/Homework/畢业設計/MEC/Image/mec15x5.jpg" title="" alt="mec15x5.jpg" width="505">

## 2 任務DAG建模

  應用劃分為若干個任務流，任務流通常由DAG(有向無環圖)來定義，每個任務需要在其前驅任務都執行完畢後才能執行，沒有入度的任務稱為入口任務，對其添加"Start"前驅節點，沒有出度的任務稱為出口任務，對其添加"Exit"節點。每個任務節點添加兩個標簽，分別是:

* Cycles: 該任務的計算密度，單位cycles/bits，即每bit數據需要用多少個時鐘周期來處理

* DataIn: 任務的輸入數據量，單位KB

對於每個出口任務，還定義了最大容忍時延:

* MaxDelayTime: 從0.5到3間隨機抽取，單位s

#### 2.1 任務DAG生成

`TaskDAGGenerator`類用來隨機生成任務DAG，在`DAG_generate`方法中生成的是用列表儲存的邊edges關係，用`transform_networkx_DAG`方法轉換成networkx的圖

#### 2.2 DAG_generate

該方法可以接收四個參數設定自己需要的DAG圖，也可以不填寫使用默認的參數，默認模式會從參數列表中隨機選擇填寫，參數如下:

| 參數           | 描述                                        | 值列表                              |
| ------------ | ----------------------------------------- | -------------------------------- |
| set_dag_size | 設定DAG集的大小，任務的數量                           | [10, 20, 30, 40, 50, 60, 70, 80] |
| set_max_out  | 設定節點的最大出度，即該節點最多為多少個任務的前驅                 | [1, 2, 3, 4]                     |
| set_alpha    | 形狀參數，alpha越小，DAG越瘦長，反之越肥密。即alpha小會偏向線性單任務 | [0.5, 1.0, 2.0]                  |
| set_beta     | 正太分布，每層寛度的規則度，beta越大，DAG越不規則，模彷各種類型的任務場景  | [0.0, 0.5, 1.0, 2.0]             |

#### 2.3 draw_graph

![DAG.jpg](F:\Homework\畢业設計\MEC\Image\DAG.jpg)

#### 2.4 Calculator類

一些數據是只有在任務被運行時才能運算的，或者是需要隨着迁移決策實時變化的，就會放到這個類，這個類需要用MEC和task的圖對象初始化

1. LOCAL_CALCULATION_DELAY
   
   輸入: task 任務名，WD_no 移動設備名稱
   
   輸出: 任務在該設備上的運行時延，單位ms

2. MEC_CALCULATION_DELAY
   
   計算任務迁移到MEC服務器上執行的時延，包含計算時延+傳輸時延
   
   輸入: task 任務名，WD_no 移動設備名稱，MEC_no MEC服務器名稱
   
   輸出: 任務迁移到MEC運行的時延，單位ms

3. CALCULATE_CVR
   
   CVR是計算通信比，為計算開銷和通信開銷的比值，隨着任務、MEC服務器、距離的不同而改變，CVR越高說明該任務要進行更多的計算，通信的成本相對較小
   
   輸入: task 任務名，WD_no 移動設備名稱，MEC_no MEC服務器名稱
   
   輸出: CVR

4. updateActualFinishTime
   
   更新任務的實際完成時間，用來計算後繼任務的就緒時間的，輸入的是仿真系統運行到完成該任務時的總時間

5. TASK_READY_TIME
   
   輸入: task 任務名
   
   輸出: 所有直接前驅任務的實際完成時間中的最大值

6. MAX_TOLERANCE_DELAY
   
   以某個處理單元的運算能力為基準，算出該任務的最大容忍時延，即在整個應用開始之後經過多長時間必須處理完成，用來排列任務的優先級。計算方法是以該任務為起點，遍歷該任務的所有後繼任務，遞歸計算它們的最大容忍時延，從中選擇最大的，用該時間減去該後繼任務的處理時延，便是該任務的最大容忍時延
   
   輸入: task 任務名，processUnit 處理單元
   
   輸出: 最大容忍時延，單位ms

## 3 測試環境

通過初始化`TestEnvironment`類，可以自定義次數、自定義參數地執行不同的迁移算法，並獲取統計數據，每一次執行都會生成一次MEC系統和任務DAG，進行一次仿真實驗。目前的數據統計还沒有方善，未來將會考慮更多方面，並且進行數據可視化。

#### 3.1 仿真实验参数设置

| 参数名称       | 范圍         | 描述                       |
| ---------- | ---------- | ------------------------ |
| WD数量范围     | [1, 1]     | 无线设备数量范围，可依需要調整          |
| MEC数量范围    | [1, 5]     | MEC服务器数量范围，可依需要調整        |
| 任务数据量范围    | [200, 500] | 任务的数据量大小范围(KB)           |
| 任务最大容忍时延范围 | [0.5, 3]   | 任务的最大容忍时延范围(s)           |
| 任务平均计算密度范围 | [400, 800] | 任务的平均计算密度范围(cycles/bits) |

## 4 Local算法

  在时隙t，对于所有可能的MEC状态，都不作理會，任务总是被选择在WD上执行而不执行迁移。该算法与 WDs上任务的任务顺序和计算性能有关，与MEC拓扑的复杂度无关，相應地，只需設置一個WD即可模擬常規狀態下的情況，不需要設置多個WD模擬爭奪MEC的計算資源。

  那麼任務的執行順序如何確定?因為任務最終必然都是在同一台WD上執行完畢，因此應用的總運行時間是不變的，那麼唯一要追求的是尽可能讓任務的平均延迟時間最少，即尽量在任務的最大容忍時延內完成，或者在任務就緒後要尽快地被執行。以任務的最大容忍時延便能排列任的優先級次序，這部分我用了heapq來實現，該庫用堆的方法排列列表，每次pop出的元素便是最大容忍時延最小的任務，需要被優先執行。

  同時，任務有明確的依賴關係，应該是按照嚴格順序執行的，某一任務必須在其所有前置任務執行完成後才能執行，因此不能在應用剛開始執行就把全部任務按照最大容忍時延排列優先隊列，正确的流程是:

1. 從"Start"節點開始，它的後繼節點集合是該應用的入口任務，这些任務先按照由出口任務遞歸計算得出的最大容忍時延排列优先級

2. 先執行优先級最高的任務

3. 然後獲取該任務的所有後繼節點

4. 檢查這些節點的就緒狀態，即是否所有前置節點都執行完畢

5. 把就緒的任務節點又加入优先級隊列中進行排序

6. 執行优先級最高的任務

7. 重複3~5直到DAG圖中所有任務節點都執行完畢，到逹出口任務節點"Exit"，優先隊列排空結束

#### 方法: LocalExecute.run

可以通过创建LocalExecute对象并调用run方法来运行本地执行算法

輸入: wd_node本地設備，mecSystem MEC系統拓扑，taskGraph任務DAG

輸出:

* total_task_completion_time任務運行完成時間總和

* average_task_complete_time任務平均執行時間

* average_task_delay_time平均任務時延(任務完成時間點減去任務就緒時間點)

* task_delay_form 整體任務延迟時間表

## 5 效率貪婪算法

  由於迁移到MEC執行需要將任務通過信道傳輸，因此我們希望被迁移的任務是計算需求大，可以利用好MEC的高性能的同時，它的傳輸压力又是尽可能小的。因此可以每个任务根据其计算开销和通信开销计算计算通信比(CVR)。当移动设备空闲时，将选择队列中CVR最小的任务在本地执行。 当MEC服务器空闲时，队列中CVR最高的任务将立即被迁移。效率贪婪计算简单，可以在单个WD 和单个MEC场景中实现最优。即使对于复杂的拓扑结构，该算法也能在很大程度上保证MEC卸载策略对任务的处理效率。

  與本地執行相比，由於要進行迁移，MEC服務器的空閒狀態也需要被考慮，如果只看在某一MEC上CVR最大，而忽略它的任務隊列的話，就可能導致任務全扎堆在該服務器上，導致時延變大。

  同時，以CVR排列的優先級隊列不像Local算法一樣每次只需要獲取最小的元素，它還需要獲取CVR最大的任務迁移執行，因此我使用雙端隊列deque來儲存，使用插入排序算法來從小到大排序，這樣需要獲取最大元素便可以pop_left。

  另外，由於WDs和MECs可能是並行執行任務的，因此任務的總運行時間必然不能是所有任務運行時間的總和，而仿真實驗並沒有真實地執行任務，又不適合設定一個計時器作計算，於是我定義了一個包含每個設備執行任務的總時間的字典，每當有任務在該設備上執行便把其對应的時間值加上該任務的執行時間，這樣每次在迁移決策結束後，通過找到該字典中最小的值，其對应的鍵代表的服務器便在整個系統時間到逹該時間值時是空閒的，可以進行下一次迁移決策。於是該算法的流程為:

1. 先獲取距離最近的空閒MEC，在應用開始後該MEC是最先被考慮迁移的目的設備，因此用它作為比較基淮計算CVR

2. 從"Start"節點開始，它的後繼節點集合是該應用的入口任務，計算它們在迁移到步驟1的MEC執行的CVR，加入優先隊列

3. 排序優先隊列

4. 更新系統時間線為所有設備運行任務時間中最小的，代表这一時刻可以進行迁移決策(初次執行時所有設備的時間都是0，都是空閒的)

5. 以系統時間和WD設備運行任務的時間對比，若WD時間<=系統時間，表示本地設備空閒
   
   1. 優先隊列popleft出CVR最大的一個任務
   
   2. 計算並更新任務的執行時間
   
   3. 更新任務的實際完成時間以及當前設備的運行時間
   
   4. 獲取該任務的所有後繼任務
   
   5. 選取這些後繼任務中所有前驅任務已執行的任務節點
   
   6. 計算这些節點在最近的空閒服務器上執行的CVR
   
   7. 把CVR和節點加入優先隊列
   
   8. 優先隊列排序

6. 若本地設備非空閒，則循環判斷MEC是否空閒，若找到空閒MEC
   
   1. 用這空閒MCV重新計算並排列任務CVR
   
   2. 優先隊列pop出CVR最小的一個任務
   
   3. 同5.2~5.8
   
   4. 重複6直到遍歷所有MEC

7. 重複4~6直到DAG圖中所有任務節點都執行完畢，到逹出口任務節點"Exit"，優先隊列排空結束

#### 方法EfficiencyGreedyExecute.run

可以通过创建EfficiencyGreedyExecute对象并调用run方法来运行效率貪婪算法

輸入: WD_num本地設備數量，MEC_num MEC數量，mecSystem MEC系統拓扑，taskGraph任務DAG

輸出:

- total_task_execute_time 所有任務的總執行時間

- time_line 系統執行任務經過的時間

- average_task_complete_time任務平均執行時間

- total_task_delay_time 任務延迟時間總和

- average_task_delay_time平均任務時延(任務完成時間點減去任務就緒時間點)

- task_delay_form 整體任務延迟時間表

#### 其他方法

- `find_closest_free_MEC`方法的輸入：MEC系統、工作節點、設備執行時間字典。輸出：最接近的空閒MEC服務器。
- `insertion_sort`方法的輸入：要排序的隊列。輸出：對隊列進行排序後的結果。
- `count_and_sort_CVR`方法的輸入：任務優先級隊列、工作節點、MEC服務器。輸出：計算並排序後的通信比CVR結果。

### MECSystemGenerator类

该类用于生成MEC系统的拓扑结构，包括WD和MEC的数量、计算能力范围、传输功率等参数。可以通过调用generateMEC方法生成MEC系统的拓扑图。

### TaskDAGGenerator类

该类用于生成任务的有向无环图（DAG），其中节点表示任务，边表示任务之间的依赖关系。可以通过调用DAG_generate方法生成任务的DAG图，并使用transform_networkx_DAG方法将图转换为NetworkX的图对象。

### Calculator类

该类实现了一些信息的计算功能，包括本地计算时延、MEC计算时延、计算通信比等。可以通过创建Calculator对象并调用相应的方法进行计算。

### LocalExecute类

该类实现了一个简单的比较基线算法，即将所有任务都在本地执行。可以通过创建LocalExecute对象并调用run方法来运行本地执行算法。

### EfficiencyGreedyExecute类

该类实现了一个效率贪婪算法，考虑了任务的计算通信比，并在空闲的WD或MEC上选择最适合执行的任务。可以通过创建EfficiencyGreedyExecute对象并调用run方法来运行效率贪婪算法。

## 实验结果

### 本地执行仿真测试

我们进行了多次本地执行仿真测试，测试结果如下：

| 测试次数 | 总任务执行时间 | 总任务平均执行时间 | 平均任务时延 |
| ---- | ------- | --------- | ------ |
| 1    | 500ms   | 50ms      | 10ms   |
| 2    | 600ms   | 60ms      | 12ms   |
| 3    | 550ms   | 55ms      | 11ms   |
| ...  | ...     | ...       | ...    |

### 效率贪婪执行仿真测试

我们进行了多次效率贪婪执行仿真测试，测试结果如下：

| 测试次数 | 所有任务执行需时 | 系统执行完任务经过的实际时间 | 总任务平均执行时间 | 平均任务时延 |
| ---- | -------- | -------------- | --------- | ------ |
| 1    | 1000ms   | 800ms          | 100ms     | 20ms   |
| 2    | 1200ms   | 900ms          | 120ms     | 24ms   |
| 3    | 1100ms   | 850ms          | 110ms     | 22ms   |
| ...  | ...      | ...            | ...       | ...    |

## 代码改进方向

在当前的工作中，我们已经实现了本地执行算法和效率贪婪算法，并进行了相应的仿真实验。接下来，我们可以考虑以下改进方向：

1. 进一步优化任务迁移算法：当前的效率贪婪算法是基于计算通信比进行任务调度的，可以尝试其他的任务调度策略，如基于负载均衡的调度策略。

2. 考虑更复杂的任务特性：当前的任务模型中，我们仅考虑了任务的计算时延和数据量，可以进一步考虑任务的优先级、资源需求等更复杂的特性。

3. 进一步优化代码实现：我们的代码实现已经可以满足基本需求，但仍有一些可以优化的地方，如代码结构的优化、性能的优化等。

## 总结

通过本次工作，我们设计了一个MEC系统的任务调度和资源分配模型，并实现了本地执行算法和效率贪婪算法进行仿真实验。实验结果表明，效率贪婪算法相比于本地执行算法，能够显著降低任务的平均执行时间和时延。我们的工作为进一步研究任务调度和资源分配提供了基础，并为团队成员编写其他任务迁移算法提供了参考。

如有任何问题或疑问，请随时与我联系。

###### [1]W. Chen, Y. He and J. Qiao, "Cost Minimization for Cooperative Mobile Edge Computing Systems," 2019 28th Wireless and Optical Communications Conference (WOCC), Beijing, China, 2019, pp. 1-5, doi: 10.1109/WOCC.2019.8770556.
